package ru.melanxoluk.hodor.secure

import io.jsonwebtoken.Jwts
import io.jsonwebtoken.SignatureAlgorithm
import org.joda.time.DateTime
import org.koin.core.component.KoinComponent
import org.slf4j.LoggerFactory
import ru.melanxoluk.hodor.domain.context.UserContext
import java.util.*


class ParsedToken(val username: String,
                  val clientUuid: UUID,
                  val userUuid: UUID,
                  val appUuid: UUID)

class TokenService(private val key: String): KoinComponent {
    companion object {
        private val logger = LoggerFactory.getLogger(TokenService::class.java)

        private const val CLIENT_CLAIM = "clt"
        private const val USER_CLAIM = "usr"
        private const val APP_CLAIM = "app"
    }


    @Deprecated("email is too small information about. Will removed")
    fun generate(email: String) =
        Jwts.builder()
            .claim("email", email)
            .setExpiration(DateTime().plusHours(1).toDate())

            // todo: differ keys for apps
            .signWith(SignatureAlgorithm.HS512, key)
            .compact()

    fun generate(context: UserContext) =
        Jwts.builder()
            // default claims
            .setIssuedAt(Date())
            .setExpiration(DateTime.now().plusDays(1).toDate())
            .setSubject(context.username)

            // hodor specific claims
            .claim(CLIENT_CLAIM, context.clientUuid)
            .claim(USER_CLAIM, context.userUuid)
            .claim(APP_CLAIM, context.appUuid)

            .signWith(SignatureAlgorithm.HS512, key)
            .compact()


    fun parse(token: String): ParsedToken {
        val allClaims = Jwts.parser().setSigningKey(key).parseClaimsJws(token).body
        return ParsedToken(
            allClaims.subject,
            UUID.fromString(allClaims[CLIENT_CLAIM].toString()),
            UUID.fromString(allClaims[USER_CLAIM].toString()),
            UUID.fromString(allClaims[APP_CLAIM].toString()))
    }

    fun isValidExpiration(token: String): Boolean {
        // todo
        //   provide additional logging of ip
        //   which from send not parsables tokens
        //   generated by somebody else, in tries
        //   to know original key
        try {
            val allClaims = Jwts.parser().setSigningKey(key).parseClaimsJws(token).body
            val expiration = allClaims.expiration
            if (expiration.after(Date())) return true
            return false
        } catch (t: Throwable) {
            logger.error(t.message, t)
            return false
        }
    }

    fun refresh(token: String): String {
        val parsed = parse(token)
        return Jwts.builder()
            // default claims
            .setIssuedAt(Date())
            .setExpiration(DateTime.now().plusDays(1).toDate())
            .setSubject(parsed.username)

            // hodor specific claims
            .claim(CLIENT_CLAIM, parsed.clientUuid)
            .claim(USER_CLAIM, parsed.userUuid)
            .claim(APP_CLAIM, parsed.appUuid)

            .signWith(SignatureAlgorithm.HS512, key)
            .compact()
    }
}
